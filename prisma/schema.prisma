generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  user
  admin
}

enum FollowKind {
  topic
  outlet
}

enum BiasBucket {
  left
  center
  right
  unknown
}

// Ground News parity: 7-category media bias rating (plus unknown).
// We keep BiasBucket for legacy 3-bucket grouping while storing the richer rating here.
enum OutletBiasRating {
  far_left
  left
  lean_left
  center
  lean_right
  right
  far_right
  unknown
}

enum FactualityBucket {
  very_high
  high
  mixed
  low
  very_low
  unknown
}

enum ArchiveStatus {
  success
  blocked
  not_found
  fallback
  error
}

enum IngestionStatus {
  ok
  error
}

enum DigestStatus {
  queued
  sent
  skipped
  failed
}

enum ThemePreference {
  light
  dark
  auto
}

model User {
  id           String    @id
  email        String    @unique
  role         UserRole  @default(user)
  createdAt    DateTime  @default(now())
  passwordSalt String?
  passwordHash String?

  sessions     Session[]
  prefs        UserPrefs?
  follows      Follow[]
  reading      ReadingEvent[]
  pushSubscriptions PushSubscription[]
  passwordResets PasswordResetToken[]
  savedStories SavedStory[]
  customFeeds  CustomFeed[]
  feedback     Feedback[]
  oauthAccounts OAuthAccount[]
  digestDeliveries DigestDelivery[]
  digestJobs    DigestJob[]
}

model Session {
  token     String   @id
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model UserPrefs {
  userId     String          @id
  edition    String          @default("International")
  localLabel String?
  localLat   Float?
  localLon   Float?
  theme      ThemePreference @default(light)
  notifyDailyBriefing Boolean @default(false)
  notifyBlindspot     Boolean @default(false)
  notifyFollowed      Boolean @default(false)
  updatedAt  DateTime        @updatedAt

  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Follow {
  id        String     @id
  userId    String
  kind      FollowKind
  slug      String
  createdAt DateTime   @default(now())

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, kind, slug])
  @@index([userId])
  @@index([kind, slug])
}

model ReadingEvent {
  id              String   @id
  userId          String
  storyId         String
  readAt          DateTime @default(now())
  dwellMs         Int?
  sourceOutletSlug String?

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  story           Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([storyId, readAt])
}

model Story {
  id           String   @id
  slug         String   @unique
  canonicalUrl String?
  title        String
  dek          String?
  author       String?
  summary      String
  topic        String
  location     String
  imageUrl     String
  publishedAt  DateTime
  updatedAt    DateTime
  sourceCount  Int

  biasLeft     Int
  biasCenter   Int
  biasRight    Int

  // Nullable because GN does not always provide this signal; we persist when available.
  originalReportingPct Int?

  isBlindspot  Boolean  @default(false)
  isLocal      Boolean  @default(false)
  isTrending   Boolean  @default(false)
  homepageRank Int?
  homepageFeaturedAt DateTime?
  lastRefreshedAt DateTime?
  staleAt         DateTime?
  readTimeMinutes Int?
  imageAssetKey   String?
  brokeTheNewsSourceId String?

  coverageTotal  Int?
  coverageLeft   Int?
  coverageCenter Int?
  coverageRight  Int?

  tags         StoryTag[]
  sources       SourceArticle[]
  reading       ReadingEvent[]
  savedBy      SavedStory[]
  feedback     Feedback[]
  snapshots    StorySnapshot[]
  timelineEvents StoryTimelineEvent[]
  podcastReferences StoryPodcastReference[]
  readerLinks  StoryReaderLink[]
  relatedFrom  StoryRelatedStory[] @relation("StoryRelatedFrom")
  relatedTo    StoryRelatedStory[] @relation("StoryRelatedTo")
  geo          StoryGeo?
  brokeTheNewsSource SourceArticle? @relation("BrokeTheNewsSource", fields: [brokeTheNewsSourceId], references: [id], onDelete: SetNull)

  @@index([updatedAt])
  @@index([staleAt])
  @@index([topic])
  @@index([location])
  @@index([brokeTheNewsSourceId])
  @@index([homepageRank])
}

model PushSubscription {
  id        String   @id
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model StoryTag {
  id      String @id
  storyId String
  tag     String

  story   Story  @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([storyId, tag])
  @@index([tag])
}

model Outlet {
  id             String           @id
  slug           String           @unique
  name           String
  logoUrl        String?
  // Ground News identifiers to allow robust enrichment joins.
  groundNewsSourceId   String?
  groundNewsSourceSlug String?
  groundNewsUrl        String?
  websiteUrl     String?
  description    String?
  country        String?
  foundedYear    Int?
  // 3-bucket bias grouping used throughout the app (Left/Center/Right).
  bias           BiasBucket       @default(unknown)
  // 7-category rating for GN parity surfaces (Far Left..Far Right).
  biasRating     OutletBiasRating @default(unknown)
  factuality     FactualityBucket @default(unknown)
  ownership      String?          // Optional; "Unlabeled" can be rendered in UI.
  lastEnrichedAt DateTime?

  sources        SourceArticle[]
  ownershipEntities OutletOwnershipEntity[] @relation("OutletOwnershipEntities")
  ownershipEdges OutletOwnershipEdge[] @relation("OutletOwnershipEdges")

  @@index([bias])
  @@index([biasRating])
  @@index([factuality])
  @@index([groundNewsSourceId])
  @@index([groundNewsSourceSlug])
  @@index([groundNewsUrl])
}

model SourceArticle {
  id          String           @id
  storyId     String
  outletId    String
  url         String
  excerpt     String
  publishedAt DateTime?
  paywall     String?
  locality    String?
  repostedBy  Int?
  headline    String?
  byline      String?
  imageUrl    String?
  language    String?
  canonicalHash String?

  story       Story            @relation(fields: [storyId], references: [id], onDelete: Cascade)
  outlet      Outlet           @relation(fields: [outletId], references: [id], onDelete: Cascade)
  brokeTheNewsFor Story[]      @relation("BrokeTheNewsSource")

  @@index([storyId])
  @@index([outletId])
  @@index([url])
  @@index([canonicalHash])
}

model ArchiveEntry {
  id          String        @id
  originalUrl String        @unique
  status      ArchiveStatus
  archiveUrl  String
  title       String
  notes       String
  paragraphs  Json
  checkedAt   DateTime
}

model IngestionRun {
  id               String         @id
  startedAt        DateTime       @default(now())
  finishedAt       DateTime?
  status           IngestionStatus
  routeCount       Int
  uniqueStoryLinks Int
  ingestedStories  Int
  errors           Json?
}

model NewsletterSignup {
  id        String   @id
  list      String
  email     String
  createdAt DateTime @default(now())

  @@index([list])
  @@index([email])
}

model PasswordResetToken {
  id        String   @id
  userId    String
  tokenHash String   @unique
  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model SavedStory {
  id        String   @id
  userId    String
  storyId   String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([userId, storyId])
  @@index([userId, createdAt])
  @@index([storyId])
}

model CustomFeed {
  id          String   @id
  userId      String
  name        String
  description String?
  // Rules are stored as JSON to allow maximalist parity iteration without schema churn.
  // Expected shape: { topics: string[], outlets: string[], includeBlindspot?: boolean, includeLocal?: boolean, includeTrending?: boolean }
  rules       Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, updatedAt])
}

enum FeedbackKind {
  summary
  story
  bug
  other
}

model Feedback {
  id        String       @id
  kind      FeedbackKind @default(summary)
  message   String
  email     String?
  url       String?
  userAgent String?
  createdAt DateTime     @default(now())

  userId    String?
  storyId   String?

  user      User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  story     Story?       @relation(fields: [storyId], references: [id], onDelete: SetNull)

  @@index([kind, createdAt])
  @@index([storyId, createdAt])
  @@index([userId, createdAt])
}

model StorySnapshot {
  id        String   @id
  storyId   String
  sourceUrl String?
  title     String?
  body      String
  metadata  Json?
  createdAt DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId, createdAt])
}

model StoryTimelineEvent {
  id        String   @id
  storyId   String
  label     String
  detail    String?
  eventAt   DateTime?
  order     Int      @default(0)
  createdAt DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId, order])
  @@index([eventAt])
}

model StoryPodcastReference {
  id         String   @id
  storyId    String
  label      String
  url        String?
  provider   String?
  createdAt  DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId])
}

model StoryReaderLink {
  id         String   @id
  storyId    String
  label      String?
  url        String
  createdAt  DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId])
  @@index([url])
}

model StoryRelatedStory {
  id            String   @id
  storyId       String
  relatedStoryId String
  reason        String?
  createdAt     DateTime @default(now())

  story       Story @relation("StoryRelatedFrom", fields: [storyId], references: [id], onDelete: Cascade)
  relatedStory Story @relation("StoryRelatedTo", fields: [relatedStoryId], references: [id], onDelete: Cascade)

  @@unique([storyId, relatedStoryId])
  @@index([relatedStoryId])
}

model StoryGeo {
  id        String   @id
  storyId   String   @unique
  lat       Float
  lon       Float
  locality  String?
  country   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)
}

model OutletOwnershipEntity {
  id          String   @id
  outletId    String
  name        String
  entityType  String?
  country     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  outlet Outlet @relation("OutletOwnershipEntities", fields: [outletId], references: [id], onDelete: Cascade)
  edgesFrom OutletOwnershipEdge[] @relation("OwnershipEntityFrom")
  edgesTo   OutletOwnershipEdge[] @relation("OwnershipEntityTo")

  @@index([outletId])
}

model OutletOwnershipEdge {
  id           String   @id
  outletId     String
  fromEntityId String
  toEntityId   String
  sharePct     Float?
  createdAt    DateTime @default(now())

  outlet Outlet @relation("OutletOwnershipEdges", fields: [outletId], references: [id], onDelete: Cascade)
  fromEntity OutletOwnershipEntity @relation("OwnershipEntityFrom", fields: [fromEntityId], references: [id], onDelete: Cascade)
  toEntity   OutletOwnershipEntity @relation("OwnershipEntityTo", fields: [toEntityId], references: [id], onDelete: Cascade)

  @@index([outletId])
  @@index([fromEntityId])
  @@index([toEntityId])
}

model DigestJob {
  id        String       @id
  userId    String?
  email     String
  list      String
  frequency String
  payload   Json?
  status    DigestStatus @default(queued)
  error     String?
  queuedAt  DateTime     @default(now())
  sentAt    DateTime?

  deliveries DigestDelivery[]
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status, queuedAt])
  @@index([email, queuedAt])
}

model DigestDelivery {
  id          String       @id
  userId      String?
  digestJobId String
  provider    String
  providerId  String?
  status      DigestStatus @default(queued)
  sentAt      DateTime?
  createdAt   DateTime     @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  digestJob DigestJob @relation(fields: [digestJobId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([digestJobId])
}

model ApiRateLimitCounter {
  id        String   @id
  namespace String
  identifier String
  count     Int      @default(0)
  windowKey String
  resetAt   DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([namespace, identifier, windowKey])
  @@index([resetAt])
}

model OAuthAccount {
  id                 String   @id
  userId             String
  provider           String
  providerAccountId  String
  email              String?
  accessToken        String?
  refreshToken       String?
  expiresAt          DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}
